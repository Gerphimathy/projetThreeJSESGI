<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Projet final de WebGL</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>
		<div id="container"></div>
		<script src="../build/ammo.js"></script>
		<script type="module">

			import * as THREE from '../build/three.module.js';
            import {DoomControls} from './doomControls.js';
// 			import {OrbitControls} from "../examples/jsm/controls/OrbitControls.js";
			import Stats from "./jsm/libs/stats.module.js";

			let camera, scene, renderer;
			let layout;
            let doomControls;
            let stats;
            let wall_size = 200; // Unit : cm
			let ambient_light;
			let physics;
			let invCameraStandin;
			let clock;

			let rigidBodies = [], tmpTrans;


			const cameraHeight = 180;

			layout = readJson('layout.json');
			console.log(layout);

			Ammo().then( function(Ammo) {

				let collisionConfiguration  = new Ammo.btDefaultCollisionConfiguration(),
						dispatcher              = new Ammo.btCollisionDispatcher(collisionConfiguration),
						overlappingPairCache    = new Ammo.btDbvtBroadphase(),
						solver                  = new Ammo.btSequentialImpulseConstraintSolver();

				physics = new Ammo.btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);
				physics.setGravity(new Ammo.btVector3(0, -10, 0));

				tmpTrans = new Ammo.btTransform();


				init();
				animate();


			} );

			function readJson(file) {
				var jObject;
				var req = new XMLHttpRequest();
				req.open("GET", "./layout.json", false);
				req.onreadystatechange = function () {
					if (req.readyState === 4) {
						jObject = JSON.parse(req.responseText);
						console.log("Loaded Json: '"+file+"'");
					}
				}
				req.send();
				return jObject;
			}

			function init() {

// 			    startOrbitControls();

				scene = new THREE.Scene();
				scene.background = new THREE.TextureLoader().load('./textures/red_sky.jpg');

				generateCamera();

				clock = new THREE.Clock();

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.setAnimationLoop(animate);

                stats = new Stats();

				document.body.appendChild( renderer.domElement );
                document.getElementById("container").appendChild(stats.dom);
				scene.add(invCameraStandin);
                doomControls = new DoomControls(invCameraStandin);
                doomControls.canFly = false;
				doomControls.canLookUpDown= false;
				doomControls.rigidBody = true;
				window.addEventListener( 'resize', onWindowResize );

				generateGround();
                generateLabyrinth();
                generateLights();



			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {
				stats.begin();

				updatePhysics(clock.getDelta());

				if (invCameraStandin.position.y!==cameraHeight) invCameraStandin.position.y = cameraHeight;
				camera.position.x = invCameraStandin.position.x;
				camera.position.y = invCameraStandin.position.y;
				camera.position.z = invCameraStandin.position.z;


				camera.rotation.x = invCameraStandin.rotation.x;
				camera.rotation.y = invCameraStandin.rotation.y;
				camera.rotation.z = invCameraStandin.rotation.z;

				if (doomControls.rigidBody === false) {
					doomControls.update();
				}else{
					let moveX = 0, moveY = 0, moveZ = 0;
					if (doomControls.status.W) moveZ++;
					if (doomControls.status.S) moveZ--;

					if (doomControls.status.A) moveX--;
					if (doomControls.status.D) moveZ++;
					let resultantImpulse = new Ammo.btVector3( moveX, moveY, moveZ )
					resultantImpulse.op_mul(doomControls.moveSpeed);

					let physicsBody = invCameraStandin.userData.physicsBody;
					physicsBody.setLinearVelocity( resultantImpulse );
				}
				renderer.render( scene, camera );
                stats.end();
			}

// 			function startOrbitControls(){
//                 const controls = new OrbitControls(camera, renderer.domElement);
//                 controls.minDistance = 10;
//                 controls.maxDistance = 2000;
//                 controls.enablePan = false;
//                 controls.maxPolarAngle = 85 * Math.PI / 180;
//             }

			function generateCamera(){
                camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 5000 );
                
                camera.position.x = layout.start[0]*wall_size-2*wall_size;
                camera.position.y = cameraHeight;
                camera.position.z = layout.start[1]*(wall_size)+0.5*wall_size;

                camera.rotation.set(0, -Math.PI/2, 0);

				const invMat = new THREE.MeshBasicMaterial();
				const invGeo = new THREE.BoxGeometry(wall_size*0.1, wall_size*0.1,wall_size*0.1);
				invCameraStandin = new THREE.Mesh(invGeo, invMat);

				invCameraStandin.position.x = camera.position.x;
				invCameraStandin.position.y = camera.position.y;
				invCameraStandin.position.z = camera.position.z;

				invCameraStandin.rotation.set(0, -Math.PI/2, 0);

				scene.add(invCameraStandin);

				let transform = new Ammo.btTransform();
				transform.setIdentity();
				transform.setOrigin(new Ammo.btVector3(camera.position.x, camera.position.y, camera.position.z));
				transform.setRotation( new Ammo.btQuaternion( camera.rotation.x, camera.rotation.y, camera.rotation.z, 1 ) );

				let motionState = new Ammo.btDefaultMotionState( transform );
				let colShape = new Ammo.btBoxShape( new Ammo.btVector3( wall_size * 0.1, wall_size * 0.1, wall_size * 0.1 ) );
				colShape.setMargin( 0.05 );


				let mass = 0;
				let localInertia = new Ammo.btVector3( 0, 0, 0 );
				colShape.calculateLocalInertia( mass, localInertia );


				let rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, colShape, localInertia );
				let body = new Ammo.btRigidBody( rbInfo );

				physics.addRigidBody( body );
				invCameraStandin.userData.physicsBody = body;

				rigidBodies.push(invCameraStandin);
			}

			function generateGround(){
				const ground_text = new THREE.TextureLoader().load('./textures/ground.jpg');
                const ground_material = new THREE.MeshPhongMaterial({map:ground_text});
                const ground_geometry = new THREE.BoxGeometry(wall_size*layout.height,50,wall_size*layout.width);
                let ground = new THREE.Mesh(ground_geometry, ground_material);
                ground.receiveShadow = true;
                ground.castShadow = true;
                ground.position.x = wall_size*layout.height/2;
                ground.position.y = -25;
                ground.position.z = wall_size*layout.width/2;
                scene.add(ground);


			}

			function generateLabyrinth(){
                let i, j;

                for(i = 0; i < layout.height; i++){
                    for(j = 0; j < layout.width; j++){
                        if(layout.layout[i][j] === 1){
                            const wall_text = new THREE.TextureLoader().load('./textures/crying_obsidian.png');
                            const wall_material = new THREE.MeshPhongMaterial({map:wall_text});
                            const wall_geometry = new THREE.BoxGeometry(wall_size,wall_size,wall_size);
	                        let wall = new THREE.Mesh(wall_geometry, wall_material);
                            wall.receiveShadow = true;
                            wall.castShadow = true;
                            wall.position.x = (j+.5)*wall_size;
                            wall.position.y = wall_size/2;
                            wall.position.z = (i+.5)*wall_size;
                            layout.layout[i][j] = wall;

                            scene.add(layout.layout[i][j]);

							let transform = new Ammo.btTransform();
							transform.setIdentity();
							transform.setOrigin(new Ammo.btVector3(wall.position.x, wall.position.y, wall.position.z));
							transform.setRotation( new Ammo.btQuaternion( wall.rotation.x, wall.rotation.y, wall.rotation.z, 1 ) );

							let motionState = new Ammo.btDefaultMotionState( transform );
							let colShape = new Ammo.btBoxShape( new Ammo.btVector3( wall_size * 0.5, wall_size * 0.5, wall_size * 0.5 ) );
							colShape.setMargin( 0.05 );


							let mass = 0;
							let localInertia = new Ammo.btVector3( 0, 0, 0 );
							colShape.calculateLocalInertia( mass, localInertia );


							let rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, colShape, localInertia );
							let body = new Ammo.btRigidBody( rbInfo );

							physics.addRigidBody( body );
							wall.userData.physicsBody = body;

							rigidBodies.push(wall);

                        }
                    }
                }

			}

            function generateLights(){
                ambient_light = new THREE.AmbientLight(0xB52020, 0.4);
                scene.add(ambient_light);
            }

			function updatePhysics(deltaTime){
				physics.stepSimulation(deltaTime,10);
				for (let i = 0; i < rigidBodies.length; i++){
					let obj = rigidBodies[i];
					let objAmmo = obj.userData.physicsBody;
					let ms = objAmmo.getMotionState();
					if (ms){
						ms.getWorldTransform(tmpTrans);
						let ori = tmpTrans.getOrigin();
						let rot = tmpTrans.getRotation();
						obj.position.set(ori.x(), ori.y(), ori.z());
						obj.quaternion.set(rot.x(), rot.y(), rot.z(), rot.w());
					}
				}
				detectCollisions();
			}

			function detectCollisions(){
				let dispatcher = physics.getDispatcher();
				let numManifolds = dispatcher.getNumManifolds();
				for (let i = 0; i < numManifolds; i++){
					let contactManifold = dispatcher.getManifoldByIndexInternal[i];
					let numContacts = contactManifold.getNumContacts();
					for (let j = 0; j < numContacts; j++){
						let contactPoint = contactManifold.getContactPoint(j);
						let distance = contactPoint.getDistance();
						console.log({manifoldIndex: i, contactIndex: j, distance: distance});
					}
				}
			}
		</script>

	</body>
</html>
