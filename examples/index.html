<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Projet final de WebGL</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>
		<div id="container"></div>
		<script type="module">

			import * as THREE from '../build/three.module.js';
            import {DoomControls} from './doomControls.js';
// 			import {OrbitControls} from "../examples/jsm/controls/OrbitControls.js";
			import Stats from "./jsm/libs/stats.module.js";

			let camera, scene, renderer;
			let layout;
            let doomControls;
            let stats;
            let wall_size = 200; // Unit : cm
			let ambient_light;
			let walls = [];

			const cameraHeight = 180;

			layout = readJson('layout.json');
			console.log(layout);


			init();
			animate();

			function readJson(file) {
				var jObject;
				var req = new XMLHttpRequest();
				req.open("GET", "./layout.json", false);
				req.onreadystatechange = function () {
					if (req.readyState === 4) {
						jObject = JSON.parse(req.responseText);
						console.log("Loaded Json: '"+file+"'");
					}
				}
				req.send();
				return jObject;
			}

			function init() {

// 			    startOrbitControls();

				generateCamera();


				scene = new THREE.Scene();
				scene.background = new THREE.TextureLoader().load('./textures/red_sky.jpg');

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.setAnimationLoop(animate);

                stats = new Stats();

				document.body.appendChild( renderer.domElement );
                document.getElementById("container").appendChild(stats.dom);
                doomControls = new DoomControls(camera);
				doomControls.canBarrelroll = false;
                doomControls.canFly = false;
				doomControls.canLookUpDown = false;
				window.addEventListener( 'resize', onWindowResize );

				generateGround();
                generateLabyrinth();
                generateLights();



			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {
                stats.begin();
				if (camera.position.y!==cameraHeight) camera.position.y = cameraHeight;
				let tempPos = [camera.position.x, camera.position.z];
                doomControls.update();
				checkProximity(tempPos);
				renderer.render( scene, camera );
                stats.end();
			}

			function checkProximity(preMovePosition){
				for (let x = -1; x <= 1; x++){
					for (let z = -1; z <= 1; z++){
						let ray = new THREE.Raycaster(camera.position, new THREE.Vector3(x,0,z));
						let proximityCheckResults = ray.intersectObjects(walls);
						if (proximityCheckResults.length>0 && proximityCheckResults[0].distance<=10) {
							camera.position.set(preMovePosition[0], cameraHeight, preMovePosition[1]);
						}
					}
				}
			}

// 			function startOrbitControls(){
//                 const controls = new OrbitControls(camera, renderer.domElement);
//                 controls.minDistance = 10;
//                 controls.maxDistance = 2000;
//                 controls.enablePan = false;
//                 controls.maxPolarAngle = 85 * Math.PI / 180;
//             }

			function generateCamera(){
                camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 5000 );
                
                camera.position.x = layout.start[0]*wall_size-2*wall_size;
                camera.position.y = cameraHeight;
                camera.position.z = layout.start[1]*(wall_size)+0.5*wall_size;

                camera.rotation.set(0, -Math.PI/2, 0);
			}

			function generateGround(){
				const ground_text = new THREE.TextureLoader().load('./textures/ground.jpg');
                const ground_material = new THREE.MeshPhongMaterial({map:ground_text});
                const ground_geometry = new THREE.BoxGeometry(wall_size*layout.height,50,wall_size*layout.width);
                let ground = new THREE.Mesh(ground_geometry, ground_material);
                ground.receiveShadow = true;
                ground.castShadow = true;
                ground.position.x = wall_size*layout.height/2;
                ground.position.y = -25;
                ground.position.z = wall_size*layout.width/2;
                scene.add(ground);


			}

			function generateLabyrinth(){
                let i, j;

                for(i = 0; i < layout.height; i++){
                    for(j = 0; j < layout.width; j++){
                        if(layout.layout[i][j] === 1){
                            const wall_text = new THREE.TextureLoader().load('./textures/crying_obsidian.png');
                            const wall_material = new THREE.MeshPhongMaterial({map:wall_text});
                            const wall_geometry = new THREE.BoxGeometry(wall_size,wall_size,wall_size);
	                        let wall = new THREE.Mesh(wall_geometry, wall_material);
                            wall.receiveShadow = true;
                            wall.castShadow = true;
                            wall.position.x = (j+.5)*wall_size;
                            wall.position.y = wall_size/2;
                            wall.position.z = (i+.5)*wall_size;
                            layout.layout[i][j] = wall;
                            scene.add(layout.layout[i][j]);
							walls.push(wall);

                        }
                    }
                }

			}

            function generateLights(){
                ambient_light = new THREE.AmbientLight(0xB52020, 0.4);
                scene.add(ambient_light);
            }

		</script>

	</body>
</html>
