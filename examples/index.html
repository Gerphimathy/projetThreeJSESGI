<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Projet final de WebGL</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<audio id="fire" preload="auto" style="display: none">
		<source src="son/feu.mp3" type="audio/mpeg">
	</audio>
	<audio id="door" preload="auto" style="display: none">
		<source src="son/porte.mp3" type="audio/mpeg">
	</audio>
	<body>
		<div id="container"></div>
		<script src="js/libs/ammo.wasm.js"></script> <!-- Ammo -->
		<script type="module">

			import * as THREE from '../build/three.module.js';
            import {DoomControls} from './doomControls.js';
// 			import {OrbitControls} from "../examples/jsm/controls/OrbitControls.js";
			import Stats from "./jsm/libs/stats.module.js";
			import {RoughnessMipmapper} from "./jsm/utils/RoughnessMipmapper.js";
			import {GLTFLoader} from "./jsm/loaders/GLTFLoader.js";
            import { ConvexObjectBreaker } from './jsm/misc/ConvexObjectBreaker.js';
//            import { ConvexGeometry } from './jsm/geometries/ConvexGeometry.js';
            import { GUI } from './jsm/libs/lil-gui.module.min.js';

			let camera, scene, renderer;
			let layout;
            let doomControls;
            let stats;
            let gui;
            const clock = new THREE.Clock();
            let enable_screamer = true;
            let devmod = true;
            let wall_size = 280; // Unit : cm
			let ambient_light;
			let torchesHolders = []; let torchesFire = []; let torchesLights = []; let torchesAnalysers = []; let torchesAudio = []; let torchesOn = false;
			let activateLights = [];
			let lightVariation = 1;
			let walls = [];
			let spookyRunner = [];
			let screamerElems = [];

			let openingDoor = [];

			const listener = new THREE.AudioListener();
			const cameraHeight = 180;
			layout = readJson('layout.json');
			console.log(layout);

            // Physics variables
            const gravityConstant = 9.8;
            let collisionConfiguration;
            let dispatcher;
            let broadphase;
            let solver;
            let physicsWorld;
            const margin = 0.05;

            const convexBreaker = new ConvexObjectBreaker();

            // Rigid bodies include all movable objects
            const rigidBodies = [];

            const pos = new THREE.Vector3();
            const quat = new THREE.Quaternion();
            let transformAux1;
            let tempBtVec3_1;

            const objectsToRemove = [];

            for ( let i = 0; i < 500; i ++ ) {

                objectsToRemove[ i ] = null;

            }

            let numObjectsToRemove = 0;

            const impactPoint = new THREE.Vector3();
            const impactNormal = new THREE.Vector3();


            Ammo().then( function ( AmmoLib ) {

                Ammo = AmmoLib;


                init();
                animate();

            } );

			function degrees_to_radians(degrees)
			{
			  let pi = Math.PI;
			  return degrees * (pi/180);
			}

			function readJson(file) {
				let jObject;
				let req = new XMLHttpRequest();
				req.open("GET", "./layout.json", false);
				req.onreadystatechange = function () {
					if (req.readyState === 4) {
						jObject = JSON.parse(req.responseText);
						console.log("Loaded Json: '"+file+"'");
					}
				}
				req.send();
				return jObject;
			}

			function init() {

// 			    startOrbitControls();

				generateCamera();

				scene = new THREE.Scene();
				scene.background = new THREE.TextureLoader().load('./textures/red_sky.jpg');
				scene.fog = new THREE.Fog(new THREE.Color(0xdd0000), 0.25, wall_size*6);

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.setAnimationLoop(animate);

                stats = new Stats();

				document.body.appendChild( renderer.domElement );
                document.getElementById("container").appendChild(stats.dom);
                doomControls = new DoomControls(camera);
                doomControls.canFly = true;
				window.addEventListener( 'resize', onWindowResize );

                initPhysics()

				generateGround();
                generateLabyrinth();
                generateCeiling();
                generateLights();
				generateSpooks();
				generateBonjour();
				generateHanged();
				prepareScreamers();
                buildGui();
			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {
                stats.begin();
                const deltaTime = clock.getDelta();
				//if (camera.position.y!==cameraHeight) camera.position.y = cameraHeight;
				let tempPos = [camera.position.x, camera.position.z];
                doomControls.update(deltaTime);
				checkProximity(tempPos);
				lightVariation *= -1;

				for (let i = 0; i < torchesAnalysers.length; i++) {
					torchesLights[i].angle += lightVariation*(torchesAnalysers[i].getAverageFrequency()/256);
					torchesFire[i].scale.y += lightVariation*(torchesAnalysers[i].getAverageFrequency()/256)*(wall_size*0.5);
					if(torchesFire[i].scale.y<wall_size*0.35) torchesFire[i].scale.y = wall_size*0.35;
					if(torchesFire[i].scale.y>wall_size*0.45) torchesFire[i].scale.y = wall_size*0.45;
				}

				if (!spookyRunner["active"]
						&& camera.position.x>=layout.runner.trigger[0]*wall_size && camera.position.x<(layout.runner.trigger[0]+1)*wall_size
						&& camera.position.z>=layout.runner.trigger[1]*wall_size && camera.position.z<(layout.runner.trigger[1]+1)*wall_size
				) spookyRunner["active"] = true;
				if (spookyRunner["active"]&&spookyRunner["frame"]!==layout.runner.time){

					let initX = (layout.runner.start[0]+0.5)*(wall_size);
					let initZ = (layout.runner.start[1]+0.5)*(wall_size);

					let destX = (layout.runner.end[0]+0.5)*(wall_size);
					let destZ = (layout.runner.end[1]+0.5)*(wall_size);

					let distX = Math.abs(destX-initX)/layout.runner.time;
					let distZ = Math.abs(destZ-initZ)/layout.runner.time;

					if (distX<initX) spookyRunner["elem"].position.x += distX;
					else spookyRunner["elem"].position.x -= distX;

					if (distZ<initZ) spookyRunner["elem"].position.z += distZ;
					else spookyRunner["elem"].position.z -= distZ;

					spookyRunner["frame"]++;
				}
				if(spookyRunner["active"] && spookyRunner["frame"] === layout.runner.time) {
					spookyRunner.elem.position.y *= -3*wall_size;
					spookyRunner["active"] = false;
				}

				if (!openingDoor["open"]
						&& camera.position.x>=layout.door.trigger[0]*wall_size && camera.position.x<(layout.door.trigger[0]+1)*wall_size
						&& camera.position.z>=layout.door.trigger[1]*wall_size && camera.position.z<(layout.door.trigger[1]+1)*wall_size
						&& openingDoor["frame"] === 0
				) {
					openingDoor["open"] = true;
					let doorElem = document.getElementById('door');
					let doorSound = new THREE.PositionalAudio(listener);
					doorSound.setMediaElementSource(doorElem);
					doorSound.setRefDistance(wall_size*0.07);

					openingDoor["elem"].add(doorSound);
					doorElem.loop = false;
					doorElem.play();
				}


				if (openingDoor["open"] && openingDoor["frame"] !== layout.door.time){
					openingDoor["frame"]++;
					let change = (layout.door.angle*(Math.PI/180))/layout.door.time;

					openingDoor["pivot"].rotateY(change);
				}

				if (!torchesOn
						&& camera.position.x>=layout.torchesOff.trigger[0]*wall_size && camera.position.x<(layout.torchesOff.trigger[0]+1)*wall_size
						&& camera.position.z>=layout.torchesOff.trigger[1]*wall_size && camera.position.z<(layout.torchesOff.trigger[1]+1)*wall_size
				){
					torchesOn = true;
					triggerTorches();
				}

                if(enable_screamer)
				for (let i = 0; i < layout.screamers.length; i++){
					let screamer = layout.screamers[i];
					if(!screamer.toggled && screamer.timer===0
							&& camera.position.x>=screamer.trigger[0]*wall_size && camera.position.x<(screamer.trigger[0]+1)*wall_size
							&& camera.position.z>=screamer.trigger[1]*wall_size && camera.position.z<(screamer.trigger[1]+1)*wall_size
					){
						screamerElems[i].position.y = screamer.surface[1]*wall_size/2;
						screamer.timer++;
						screamer.toggled = true;
						let effect = new Audio("./son/screamers/"+screamer.effect);
						effect.play();
					}
					if (screamer.toggled && screamer.timer!==screamer.lingering) screamer.timer++;
					if (screamer.toggled && screamer.timer===screamer.lingering) screamerElems[i].position.y = -3 * wall_size * wall_size * screamer.surface[1];
				}


                updatePhysics(deltaTime);
                renderer.render( scene, camera );
                stats.end();
			}

/*
 			function startOrbitControls(){
				const controls = new OrbitControls(camera, renderer.domElement);
                controls.minDistance = 10;
                controls.maxDistance = 2000;
                controls.enablePan = false;
                controls.maxPolarAngle = 85 * Math.PI / 180;
            }

*/

            function initPhysics() {

                // Physics configuration

                collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
                dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
                broadphase = new Ammo.btDbvtBroadphase();
                solver = new Ammo.btSequentialImpulseConstraintSolver();
                physicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration);
                physicsWorld.setGravity(new Ammo.btVector3(0, -gravityConstant, 0));

                transformAux1 = new Ammo.btTransform();
                tempBtVec3_1 = new Ammo.btVector3(0, 0, 0);
            }


			function prepareScreamers() {
				for (let i = 0; i < layout.screamers.length; i++) {
					let screamer = layout.screamers[i];
					let matArray = [];
					matArray.push(new THREE.MeshBasicMaterial({
						map: THREE.ImageUtils.loadTexture('./textures/screamers/' + screamer.path),
						transparent: true,
						opacity: 1,
						color: 0xFF0000
					}));
					matArray.push(new THREE.MeshBasicMaterial({
						map: THREE.ImageUtils.loadTexture('./textures/screamers/' + screamer.path),
						transparent: true,
						opacity: 1,
						color: 0xFF0000
					}));
					matArray.push(new THREE.MeshBasicMaterial({
						map: THREE.ImageUtils.loadTexture('./textures/screamers/' + screamer.path),
						transparent: true,
						opacity: 1,
						color: 0xFF0000
					}));
					matArray.push(new THREE.MeshBasicMaterial({
						map: THREE.ImageUtils.loadTexture('./textures/screamers/' + screamer.path),
						transparent: true,
						opacity: 1,
						color: 0xFF0000
					}));
					matArray.push(new THREE.MeshBasicMaterial({
						map: THREE.ImageUtils.loadTexture('./textures/screamers/' + screamer.path),
						transparent: true,
						opacity: 1,
						color: 0xFF0000
					}));
					matArray.push(new THREE.MeshBasicMaterial({
						map: THREE.ImageUtils.loadTexture('./textures/screamers/' + screamer.path),
						transparent: true,
						opacity: 1,
						color: 0xFF0000
					}));

					const screamerMat = new THREE.MeshFaceMaterial(matArray);

					const screamerGeo = new THREE.BoxGeometry(wall_size * screamer.surface[0], wall_size * screamer.surface[1], wall_size * screamer.surface[2]);

					let spook = new THREE.Mesh(screamerGeo, screamerMat);
					spook.position.x = (screamer.location[0] + 0.5) * wall_size;
					spook.position.y = -3 * wall_size * wall_size * screamer.surface[1];
					spook.position.z = (screamer.location[1] + 0.5) * wall_size;

					scene.add(spook);

					screamerElems.push(spook);
				}
			}


			function checkProximity(preMovePosition){
				for (let x = -1; x <= 1; x++){
					for (let z = -1; z <= 1; z++){
						let ray = new THREE.Raycaster(camera.position, new THREE.Vector3(x,0,z));
						let proximityCheckResults = ray.intersectObjects(walls);
						if (proximityCheckResults.length>0 && proximityCheckResults[0].distance<=30) {
							camera.position.set(preMovePosition[0], cameraHeight, preMovePosition[1]);
						}
					}
				}
			}

			function generateCamera(){
                camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 5000 );

                camera.position.x = layout.start[0]*wall_size+0.5*wall_size;
                camera.position.y = cameraHeight;
                camera.position.z = layout.start[1]*(wall_size)+0.5*wall_size;

                camera.rotation.set(0, -Math.PI/2, 0);
				camera.add(listener);
			}

			function generateGround(){
				const ground_text = new THREE.TextureLoader().load('./textures/ground.jpg');
                const ground_material = new THREE.MeshPhongMaterial({map:ground_text});
                const ground_geometry = new THREE.BoxGeometry(wall_size*layout.height,50,wall_size*layout.width);
                const ground = new THREE.Mesh(ground_geometry, ground_material);
                ground.receiveShadow = true;
                ground.castShadow = true;
                ground.position.x = wall_size*layout.height/2;
                ground.position.y = -25;
                ground.position.z = wall_size*layout.width/2;

                const shape = new Ammo.btBoxShape( new Ammo.btVector3( wall_size*layout.height/2, 25-margin, wall_size*layout.width/2 ) );

                createRigidBody( ground, shape, 0, 0, 0 );

			}

			function generateLabyrinth(){
                let i, j;

                for(i = 0; i < layout.height; i++){
                    for(j = 0; j < layout.width; j++){
                        if(layout.layout[i][j] === 1){
                            const wall_text = new THREE.TextureLoader().load('./textures/walls.jpg');
                            const wall_material = new THREE.MeshPhongMaterial({map:wall_text});
                            const wall_geometry = new THREE.BoxGeometry(wall_size,wall_size,wall_size);
	                        let wall = new THREE.Mesh(wall_geometry, wall_material);
                            wall.receiveShadow = true;
                            wall.castShadow = true;
                            wall.position.x = (j+.5)*wall_size;
                            wall.position.y = wall_size/2;
                            wall.position.z = (i+.5)*wall_size;
                            layout.layout[i][j] = wall;
							walls.push(wall);
                            const shape = new Ammo.btBoxShape( new Ammo.btVector3( wall_size/2, wall_size/2, wall_size/2 ) );
                            createRigidBody( wall, shape, 0, 0, 0 );

                        }
                    }
                }

				const door_text = new THREE.TextureLoader().load('./textures/gate.png');
				const door_material = new THREE.MeshPhongMaterial({map:door_text});
				const door_geometry = new THREE.BoxGeometry(wall_size,wall_size,wall_size*0.1);
				let door = new THREE.Mesh(door_geometry, door_material);

				let pivot = new THREE.Object3D();
				pivot.position.x = (layout.door.position[0]+1)*wall_size;
				pivot.position.y = wall_size/2;
				pivot.position.z = (layout.door.position[1]+1)*wall_size;

				pivot.add(door);

				door.position.x -= 0.5*wall_size;

				openingDoor = {
					elem: door,
					pivot: pivot,
					open: false,
					frame:0
				};

				scene.add(openingDoor["pivot"]);
			}

            function generateLights(){
                ambient_light = new THREE.AmbientLight(0xB52020, 0.4);
                scene.add(ambient_light);
				for (let i = 0; i < layout.torches.length; i++) {
					buildTorches(layout.torches[i][0], layout.torches[i][1], false);
				}
				for (let i = 0; i < layout.torchesLat.length; i++) {
					buildTorches(layout.torchesLat[i][0], layout.torchesLat[i][1], true);
				}
				for (let i = 0; i < layout.torchesOff.locations.length; i++){
					buildTriggeringTorches(layout.torchesOff.locations[i][0],layout.torchesOff.locations[i][1], false);
				}
            }

			function buildTorches(posX, posZ, lateral){
				const roughnessMipmapper2 = new RoughnessMipmapper(renderer);

				const torchLoader = new GLTFLoader().setPath('./models/torch/');
				const fireLoader = new GLTFLoader().setPath('./models/fire/');

				torchLoader.load('scene.gltf', function (holder) {

					holder.scene.traverse(function (child) {

						if (child.isMesh) {
							roughnessMipmapper2.generateMipmaps(child.material);
							child.castShadow = true;
							child.receiveShadow = true;
						}
					});

					holder.scene.scale.set(wall_size*0.2, wall_size*0.2, wall_size*0.2);
					if(!lateral){
						holder.scene.position.x = (posX+0.05)*wall_size;
						holder.scene.position.z = (posZ+0.5)*wall_size;
						holder.scene.position.y = wall_size*0.55;
					}else{
						holder.scene.position.z = (posZ+0.95)*wall_size;
						holder.scene.position.x = (posX+0.5)*wall_size;
						holder.scene.rotation.y += Math.PI / 2;
						holder.scene.position.y = wall_size*0.55;
					}

					torchesHolders.push(holder.scene);

					scene.add(holder.scene);

					let fireSound = new THREE.PositionalAudio(listener);
					let fireElement = document.getElementById('fire');
					fireSound.setMediaElementSource(fireElement);
					fireSound.setRefDistance(wall_size*0.09);
					holder.scene.add(fireSound);
					fireElement.play();
					fireElement.loop = true;
					torchesAudio.push(fireSound);

					let analyzer = new THREE.AudioAnalyser(fireSound,32);
					torchesAnalysers.push(analyzer);

					roughnessMipmapper2.dispose();

				});
				fireLoader.load('scene.gltf', function(fire){
					fire.scene.traverse(function (child) {

						if (child.isMesh) {
							roughnessMipmapper2.generateMipmaps(child.material);
							child.castShadow = true;
							child.receiveShadow = true;
						}
					});

					fire.scene.scale.set(wall_size*0.4, wall_size*0.4, wall_size*0.4);
					if(!lateral){
						fire.scene.position.x = (posX-1)*wall_size;
						fire.scene.position.z = (posZ-0.2)*wall_size;
						fire.scene.position.y = wall_size*0.60;
					}else{
						fire.scene.position.z = (posZ+0.2)*wall_size;
						fire.scene.position.x = (posX-0.6)*wall_size;
						fire.scene.position.y = wall_size*0.60;
					}

					scene.add(fire.scene);
					torchesFire.push(fire.scene);
					roughnessMipmapper2.dispose();
				});
				let torchLight = new THREE.SpotLight(0xFF5555, 2);
				if(!lateral){
					torchLight.position.x = (posX+1.5)*wall_size;
					torchLight.position.y = wall_size*0.60;
					torchLight.position.z = (posZ+0.5)*wall_size;
				}else{
					torchLight.position.x = (posX+1.7)*wall_size;
					torchLight.position.y = wall_size*0.60;
					torchLight.position.z = (posZ+1.5)*wall_size;
				}

				torchLight.angle = Math.PI / 4;
				torchLight.penumbra = 0.4;
				torchLight.decay = 2;
				torchLight.distance = 1500;

				torchLight.castShadow = true;
				torchLight.shadow.mapSize.width = 1024;
				torchLight.shadow.mapSize.height = 1024;
				torchLight.shadow.camera.near = 10;
				torchLight.shadow.camera.far = 200;
				torchLight.shadow.focus = 1;
				scene.add(torchLight);
				torchesLights.push(torchLight);
			}

			function buildTriggeringTorches(posX, posZ, lateral){
				const roughnessMipmapper2 = new RoughnessMipmapper(renderer);

				const torchLoader = new GLTFLoader().setPath('./models/torch/');

				torchLoader.load('scene.gltf', function (holder) {

					holder.scene.traverse(function (child) {

						if (child.isMesh) {
							roughnessMipmapper2.generateMipmaps(child.material);
							child.castShadow = true;
							child.receiveShadow = true;
						}
					});

					holder.scene.scale.set(wall_size*0.2, wall_size*0.2, wall_size*0.2);
					if(!lateral){
						holder.scene.position.x = (posX+0.05)*wall_size;
						holder.scene.position.z = (posZ+0.5)*wall_size;
						holder.scene.position.y = wall_size*0.55;
					}else{
						holder.scene.position.z = (posZ+0.95)*wall_size;
						holder.scene.position.x = (posX+0.5)*wall_size;
						holder.scene.rotation.y += Math.PI / 2;
						holder.scene.position.y = wall_size*0.55;
					}

					torchesHolders.push(holder.scene);

					scene.add(holder.scene);

					roughnessMipmapper2.dispose();

				});
				const fireLoader = new GLTFLoader().setPath('./models/fire/');

				fireLoader.load('scene.gltf', function(fire){
					fire.scene.traverse(function (child) {

						if (child.isMesh) {
							roughnessMipmapper2.generateMipmaps(child.material);
							child.castShadow = true;
							child.receiveShadow = true;
						}
					});

					fire.scene.scale.set(wall_size*0.4, wall_size*0.4, wall_size*0.4);
					if(!lateral){
						fire.scene.position.x = (posX-1)*wall_size;
						fire.scene.position.z = (posZ-0.2)*wall_size;
						fire.scene.position.y = -5*wall_size*0.60;
					}else {
						fire.scene.position.z = (posZ + 0.2) * wall_size;
						fire.scene.position.x = (posX - 0.6) * wall_size;
						fire.scene.position.y = -5*wall_size * 0.60;
					}

					let fireSound = new THREE.PositionalAudio(listener);
					let fireElement = document.getElementById('fire');
					fireSound.setMediaElementSource(fireElement);
					fireSound.setRefDistance(wall_size*0.09);
					fire.scene.add(fireSound);
					fireElement.play();
					fireElement.loop = true;
					torchesAudio.push(fireSound);

					let analyzer = new THREE.AudioAnalyser(fireSound,32);
					torchesAnalysers.push(analyzer);

					scene.add(fire.scene);
					torchesFire.push(fire.scene);
					activateLights.push(fire.scene);
					roughnessMipmapper2.dispose();
				});
				let torchLight = new THREE.SpotLight(0xFF5555, 2);
				if(!lateral){
					torchLight.position.x = (posX+1.5)*wall_size;
					torchLight.position.y = -5*wall_size*0.60;
					torchLight.position.z = (posZ+0.5)*wall_size;
				}else{
					torchLight.position.x = (posX+1.7)*wall_size;
					torchLight.position.y = -5*wall_size*0.60;
					torchLight.position.z = (posZ+1.5)*wall_size;
				}

				torchLight.angle = Math.PI / 4;
				torchLight.penumbra = 0.4;
				torchLight.decay = 2;
				torchLight.distance = 1500;

				torchLight.castShadow = true;
				torchLight.shadow.mapSize.width = 1024;
				torchLight.shadow.mapSize.height = 1024;
				torchLight.shadow.camera.near = 10;
				torchLight.shadow.camera.far = 200;
				torchLight.shadow.focus = 1;
				scene.add(torchLight);
				torchesLights.push(torchLight);
				activateLights.push(torchLight);
			}

			function triggerTorches(posX, posZ, lateral){
				for (let i = 0; i < activateLights.length; i++){
					activateLights[i].position.y = wall_size*0.60;
				}
			}

			function generateSpooks(){
				let initX = (layout.runner.start[0]+0.5)*(wall_size);
				let initZ = (layout.runner.start[1]+0.5)*(wall_size);

				var spook_material_array = [];
				spook_material_array.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( './textures/skeleton.png' ), transparent: true, opacity: 1, color: 0xFF0000 }));
				spook_material_array.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( './textures/skeleton.png' ), transparent: true, opacity: 1, color: 0xFF0000 }));
				spook_material_array.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( './textures/skeleton.png' ), transparent: true, opacity: 1, color: 0xFF0000 }));
				spook_material_array.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( './textures/skeleton.png' ), transparent: true, opacity: 1, color: 0xFF0000 }));
				spook_material_array.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( './textures/skeleton.png' ), transparent: true, opacity: 1, color: 0xFF0000 }));
				spook_material_array.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( './textures/skeleton.png' ), transparent: true, opacity: 1, color: 0xFF0000 }));

				/*const wall_text = new THREE.TextureLoader().load('./textures/skeleton.png');*/
				/*const wall_material = new THREE.MeshPhongMaterial({map:wall_text});*/

				const spook_material = new THREE.MeshFaceMaterial(spook_material_array);

				const spook_geometry = new THREE.BoxGeometry(1,wall_size,wall_size*0.5);

				let spook = new THREE.Mesh(spook_geometry, spook_material);
				spook.receiveShadow = true;
				spook.castShadow = true;
				spook.position.x = initX;
				spook.position.y = wall_size/2;
				spook.position.z = initZ;

				spookyRunner = {
					elem: spook,
					frame: 0,
					active: false
				}

				scene.add(spook);

			}

			function generateBonjour(){
				const bonjour_geometry = new THREE.BoxGeometry( 1, wall_size/3, wall_size/2.5 );
				var bonjour_material_array = [];
				bonjour_material_array.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( './textures/sign.png' ), transparent: true, opacity: 1, color: 0xFF0000 }));
				bonjour_material_array.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( './textures/sign.png' ), transparent: true, opacity: 1, color: 0xFF0000 }));
				bonjour_material_array.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( './textures/sign.png' ), transparent: true, opacity: 1, color: 0xFF0000 }));
				bonjour_material_array.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( './textures/sign.png' ), transparent: true, opacity: 1, color: 0xFF0000 }));
				bonjour_material_array.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( './textures/sign.png' ), transparent: true, opacity: 1, color: 0xFF0000 }));
				bonjour_material_array.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( './textures/sign.png' ), transparent: true, opacity: 1, color: 0xFF0000 }));
				const bonjour_material = new THREE.MeshFaceMaterial(bonjour_material_array);
				const bonjour = new THREE.Mesh( bonjour_geometry, bonjour_material );

				bonjour.position.x = layout.start[0]*wall_size + wall_size;
				bonjour.position.y = cameraHeight-20;
				bonjour.position.z = layout.start[1]*(wall_size) - 1.5*wall_size;

				scene.add( bonjour );
			}

			function generateHanged(){
				const hangedLoader = new GLTFLoader().setPath('./models/hanged/');

				hangedLoader.load('scene.gltf', function(hanged){
					hanged.scene.traverse(function (child) {

						if (child.isMesh) {
							//roughnessMipmapper2.generateMipmaps(child.material);
							child.castShadow = true;
							child.receiveShadow = true;
						}
					});

					hanged.scene.scale.set(wall_size*0.6, wall_size*0.6, wall_size*0.6);
					hanged.scene.position.x = layout.start[0]*wall_size + 11.5*wall_size;
					hanged.scene.position.y = cameraHeight-200;
					hanged.scene.position.z = layout.start[1]*(wall_size) + 4.5*wall_size;
					hanged.scene.rotation.y = degrees_to_radians(-180);

					scene.add(hanged.scene);
					//roughnessMipmapper2.dispose();
				});
			}

            function generateCeiling(){
                let i, j;
                let slab_size = 20;

                for(i = 0; i < layout.height; i++) {
                    for (j = 0; j < layout.width; j++) {
	                    const slab_text = new THREE.TextureLoader().load('./textures/walls.jpg');
	                    const slab_material = new THREE.MeshPhongMaterial({map: slab_text});
	                    const slab_geometry = new THREE.BoxGeometry(wall_size, slab_size, wall_size);
	                    const slab = new THREE.Mesh(slab_geometry, slab_material);
                        slab.position.x = (j + .5) * wall_size;
                        slab.position.y = wall_size + slab_size / 2;
                        slab.position.z = (i + .5) * wall_size;

                        if(j===layout.crumbling.position[0] && i===layout.crumbling.position[1]) {
                            convexBreaker.prepareBreakableObject(slab, 3000, new THREE.Vector3(), new THREE.Vector3(), true);
                            createDebrisFromBreakableObject(slab);
                        }else{
                            const shape = new Ammo.btBoxShape( new Ammo.btVector3( wall_size/2-margin, slab_size/2, wall_size/2-margin ) );
                            createRigidBody( slab, shape, 0, 0, 0 );
                        }

	                    scene.add(slab);

                    }
                }
            }

            //Ammo functions

            function createDebrisFromBreakableObject( object ) {

                object.castShadow = true;
                object.receiveShadow = true;

                const shape = createConvexHullPhysicsShape( object.geometry.attributes.position.array );
                shape.setMargin( margin );

                const body = createRigidBody( object, shape, object.userData.mass, null, null, object.userData.velocity, object.userData.angularVelocity );

                // Set pointer back to the three object only in the debris objects
                const btVecUserData = new Ammo.btVector3( 0, 0, 0 );
                btVecUserData.threeObject = object;
                body.setUserPointer( btVecUserData );

            }

            function removeDebris( object ) {

                scene.remove( object );

                physicsWorld.removeRigidBody( object.userData.physicsBody );

            }

            function createConvexHullPhysicsShape( coords ) {

                const shape = new Ammo.btConvexHullShape();

                for ( let i = 0, il = coords.length; i < il; i += 3 ) {

                    tempBtVec3_1.setValue( coords[ i ], coords[ i + 1 ], coords[ i + 2 ] );
                    const lastOne = ( i >= ( il - 3 ) );
                    shape.addPoint( tempBtVec3_1, lastOne );

                }

                return shape;

            }

            function createRigidBody( object, physicsShape, mass, pos, quat, vel, angVel ) {

                if ( pos ) {

                    object.position.copy( pos );

                } else {

                    pos = object.position;

                }

                if ( quat ) {

                    object.quaternion.copy( quat );

                } else {

                    quat = object.quaternion;

                }

                const transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
                transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
                const motionState = new Ammo.btDefaultMotionState( transform );

                const localInertia = new Ammo.btVector3( 0, 0, 0 );
                physicsShape.calculateLocalInertia( mass, localInertia );

                const rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, physicsShape, localInertia );
                const body = new Ammo.btRigidBody( rbInfo );

                body.setFriction( 0.5 );

                if ( vel ) {

                    body.setLinearVelocity( new Ammo.btVector3( vel.x, vel.y, vel.z ) );

                }

                if ( angVel ) {

                    body.setAngularVelocity( new Ammo.btVector3( angVel.x, angVel.y, angVel.z ) );

                }

                object.userData.physicsBody = body;
                object.userData.collided = false;

                scene.add( object );

                if ( mass > 0 ) {

                    rigidBodies.push( object );

                    // Disable deactivation
                    body.setActivationState( 4 );

                }

                physicsWorld.addRigidBody( body );

                return body;

            }


            function updatePhysics( deltaTime ) {

                // Step world
                physicsWorld.stepSimulation( deltaTime, 1 );

                // Update rigid bodies
                for ( let i = 0, il = rigidBodies.length; i < il; i ++ ) {

                    const objThree = rigidBodies[ i ];
                    const objPhys = objThree.userData.physicsBody;
                    const ms = objPhys.getMotionState();

                    if ( ms ) {

                        ms.getWorldTransform( transformAux1 );
                        const p = transformAux1.getOrigin();
                        const q = transformAux1.getRotation();
                        objThree.position.set( p.x(), p.y(), p.z() );
                        objThree.quaternion.set( q.x(), q.y(), q.z(), q.w() );

                        objThree.userData.collided = false;

                    }

                }

                for ( let i = 0, il = dispatcher.getNumManifolds(); i < il; i ++ ) {

                    const contactManifold = dispatcher.getManifoldByIndexInternal( i );
                    const rb0 = Ammo.castObject( contactManifold.getBody0(), Ammo.btRigidBody );
                    const rb1 = Ammo.castObject( contactManifold.getBody1(), Ammo.btRigidBody );

                    const threeObject0 = Ammo.castObject( rb0.getUserPointer(), Ammo.btVector3 ).threeObject;
                    const threeObject1 = Ammo.castObject( rb1.getUserPointer(), Ammo.btVector3 ).threeObject;

                    if ( ! threeObject0 && ! threeObject1 ) {

                        continue;

                    }

                    const userData0 = threeObject0 ? threeObject0.userData : null;
                    const userData1 = threeObject1 ? threeObject1.userData : null;

                    const breakable0 = userData0 ? userData0.breakable : false;
                    const breakable1 = userData1 ? userData1.breakable : false;

                    const collided0 = userData0 ? userData0.collided : false;
                    const collided1 = userData1 ? userData1.collided : false;

                    if ( ( ! breakable0 && ! breakable1 ) || ( collided0 && collided1 ) ) {

                        continue;

                    }

                    let contact = false;
                    let maxImpulse = 0;
                    for ( let j = 0, jl = contactManifold.getNumContacts(); j < jl; j ++ ) {

                        const contactPoint = contactManifold.getContactPoint( j );

                        if ( contactPoint.getDistance() < 0 ) {

                            contact = true;
                            const impulse = contactPoint.getAppliedImpulse();

                            if ( impulse > maxImpulse ) {

                                maxImpulse = impulse;
                                const pos = contactPoint.get_m_positionWorldOnB();
                                const normal = contactPoint.get_m_normalWorldOnB();
                                impactPoint.set( pos.x(), pos.y(), pos.z() );
                                impactNormal.set( normal.x(), normal.y(), normal.z() );

                            }

                            break;

                        }

                    }

                    // If no point has contact, abort
                    if ( ! contact ) continue;

                    // Subdivision

                    const fractureImpulse = 250;

                    if ( breakable0 && ! collided0 && maxImpulse > fractureImpulse ) {

                        const debris = convexBreaker.subdivideByImpact( threeObject0, impactPoint, impactNormal, 1, 2, 1.5 );

                        const numObjects = debris.length;
                        for ( let j = 0; j < numObjects; j ++ ) {

                            const vel = rb0.getLinearVelocity();
                            const angVel = rb0.getAngularVelocity();
                            const fragment = debris[ j ];
                            fragment.userData.velocity.set( vel.x(), vel.y(), vel.z() );
                            fragment.userData.angularVelocity.set( angVel.x(), angVel.y(), angVel.z() );

                            createDebrisFromBreakableObject( fragment );

                        }

                        objectsToRemove[ numObjectsToRemove ++ ] = threeObject0;
                        userData0.collided = true;

                    }

                    if ( breakable1 && ! collided1 && maxImpulse > fractureImpulse ) {

                        const debris = convexBreaker.subdivideByImpact( threeObject1, impactPoint, impactNormal, 1, 2, 1.5 );

                        const numObjects = debris.length;
                        for ( let j = 0; j < numObjects; j ++ ) {

                            const vel = rb1.getLinearVelocity();
                            const angVel = rb1.getAngularVelocity();
                            const fragment = debris[ j ];
                            fragment.userData.velocity.set( vel.x(), vel.y(), vel.z() );
                            fragment.userData.angularVelocity.set( angVel.x(), angVel.y(), angVel.z() );

                            createDebrisFromBreakableObject( fragment );

                        }

                        objectsToRemove[ numObjectsToRemove ++ ] = threeObject1;
                        userData1.collided = true;

                    }

                }

                for ( let i = 0; i < numObjectsToRemove; i ++ ) {

                    removeDebris( objectsToRemove[ i ] );

                }

                numObjectsToRemove = 0;

            }


            function buildGui() {

                gui = new GUI();

                const params = {
                    'move speed': doomControls.moveSpeed,
                    'rotation speed': doomControls.rotateSpeed,
	                'fog color': scene.fog.color,
	                'fog far': scene.fog.far,
	                'light intensity':ambient_light.intensity,
	                'light color': ambient_light.color,
	                'enable screamer': enable_screamer,
	                'devmod':devmod
                };

                let controls = gui.addFolder('Controls');

                controls.add( params, 'move speed', 300, 550).onChange(function (val) {
                    doomControls.moveSpeed = val;
                })

	            controls.add( params, 'rotation speed', Math.PI/4, Math.PI*1.5).onChange(function (val){
                    doomControls.rotateSpeed = val;
	            })

	            let fog = gui.addFolder('Fog');

                fog.addColor(params, 'fog color' ).onChange(function(val){
                    scene.fog.color = val;
                })


	            fog.add(params, 'fog far', wall_size*2, wall_size*10).onChange(function(val){
                    scene.fog.far = val;
	            })

	            let light = gui.addFolder('light');

                light.addColor(params, 'light color').onChange(function(val){
                    ambient_light.color = val;
                })

	            light.add(params, 'light intensity',0,1).onChange(function(val){
                    ambient_light.intensity = val;
	            })

	            let preferences = gui.addFolder('preferences');

                preferences.add(params, 'enable screamer').onChange(function(val){
                    enable_screamer = val;
                })

	            preferences.add(params, 'devmod').onChange(function(val){
                    devmod = val;
                    doomControls.canFly = val;
                    doomControls.canLookUpDown = val;
                    doomControls.canBarrelroll = val;

	            })

                gui.open();
            }


		</script>

	</body>
</html>
