<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Projet final de WebGL</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<audio id="fire" preload="auto" style="display: none">
		<source src="son/feu.mp3" type="audio/mpeg">
	</audio>
	<body>
		<div id="container"></div>
		<script type="module">

			import * as THREE from '../build/three.module.js';
            import {DoomControls} from './doomControls.js';
// 			import {OrbitControls} from "../examples/jsm/controls/OrbitControls.js";
			import Stats from "./jsm/libs/stats.module.js";
			import {RoughnessMipmapper} from "./jsm/utils/RoughnessMipmapper.js";
			import {GLTFLoader} from "./jsm/loaders/GLTFLoader.js";

			let camera, scene, renderer;
			let layout;
            let doomControls;
            let stats;
            let wall_size = 200; // Unit : cm
			let ambient_light;
			let torchesHolders = []; let torchesFire = []; let torchesLights = []; let torchesAnalysers = []; let torchesAudio = [];
			let lightVariation = 1;
			let walls = [];

			let doors = [];

			const listener = new THREE.AudioListener();
			const cameraHeight = 180;
			layout = readJson('layout.json');
			console.log(layout);


			init();
			animate();

			function readJson(file) {
				var jObject;
				var req = new XMLHttpRequest();
				req.open("GET", "./layout.json", false);
				req.onreadystatechange = function () {
					if (req.readyState === 4) {
						jObject = JSON.parse(req.responseText);
						console.log("Loaded Json: '"+file+"'");
					}
				}
				req.send();
				return jObject;
			}

			function init() {

// 			    startOrbitControls();

				generateCamera();

				scene = new THREE.Scene();
				scene.background = new THREE.TextureLoader().load('./textures/red_sky.jpg');
				scene.fog = new THREE.Fog(new THREE.Color(0xdd0000), 0.25, wall_size*6);

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.setAnimationLoop(animate);

                stats = new Stats();

				document.body.appendChild( renderer.domElement );
                document.getElementById("container").appendChild(stats.dom);
                doomControls = new DoomControls(camera);
                doomControls.canFly = true;
				window.addEventListener( 'resize', onWindowResize );

				generateGround();
                generateLabyrinth();
                generateLights();
			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {
                stats.begin();
				//if (camera.position.y!==cameraHeight) camera.position.y = cameraHeight;
				let tempPos = [camera.position.x, camera.position.z];
                doomControls.update();
				checkProximity(tempPos);
				renderer.render( scene, camera );
				lightVariation *= -1;
				for (let i = 0; i < torchesAnalysers.length; i++) {
					torchesLights[i].angle += lightVariation*(torchesAnalysers[i].getAverageFrequency()/256);
					torchesFire[i].scale.y += lightVariation*(torchesAnalysers[i].getAverageFrequency()/256)*(wall_size*0.5);
				}
                stats.end();
			}

/*
 			function startOrbitControls(){
				const controls = new OrbitControls(camera, renderer.domElement);
                controls.minDistance = 10;
                controls.maxDistance = 2000;
                controls.enablePan = false;
                controls.maxPolarAngle = 85 * Math.PI / 180;
            }
*/
			function checkProximity(preMovePosition){
				for (let x = -1; x <= 1; x++){
					for (let z = -1; z <= 1; z++){
						let ray = new THREE.Raycaster(camera.position, new THREE.Vector3(x,0,z));
						let proximityCheckResults = ray.intersectObjects(walls);
						if (proximityCheckResults.length>0 && proximityCheckResults[0].distance<=10) {
							camera.position.set(preMovePosition[0], cameraHeight, preMovePosition[1]);
						}
					}
				}
			}
			function generateCamera(){
                camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 5000 );
                
                camera.position.x = layout.start[0]*wall_size-2*wall_size;
                camera.position.y = cameraHeight;
                camera.position.z = layout.start[1]*(wall_size)+0.5*wall_size;

                camera.rotation.set(0, -Math.PI/2, 0);
				camera.add(listener);
			}

			function generateGround(){
				const ground_text = new THREE.TextureLoader().load('./textures/ground.jpg');
                const ground_material = new THREE.MeshPhongMaterial({map:ground_text});
                const ground_geometry = new THREE.BoxGeometry(wall_size*layout.height,50,wall_size*layout.width);
                let ground = new THREE.Mesh(ground_geometry, ground_material);
                ground.receiveShadow = true;
                ground.castShadow = true;
                ground.position.x = wall_size*layout.height/2;
                ground.position.y = -25;
                ground.position.z = wall_size*layout.width/2;
                scene.add(ground);
			}

			function generateLabyrinth(){
                let i, j;

                for(i = 0; i < layout.height; i++){
                    for(j = 0; j < layout.width; j++){
                        if(layout.layout[i][j] === 1){
                            const wall_text = new THREE.TextureLoader().load('./textures/crying_obsidian.png');
                            const wall_material = new THREE.MeshPhongMaterial({map:wall_text});
                            const wall_geometry = new THREE.BoxGeometry(wall_size,wall_size,wall_size);
	                        let wall = new THREE.Mesh(wall_geometry, wall_material);
                            wall.receiveShadow = true;
                            wall.castShadow = true;
                            wall.position.x = (j+.5)*wall_size;
                            wall.position.y = wall_size/2;
                            wall.position.z = (i+.5)*wall_size;
                            layout.layout[i][j] = wall;
                            scene.add(layout.layout[i][j]);
							walls.push(wall);

                        }
                    }
                }

				const doorLoader = new GLTFLoader().setPath('./models/door/');

				let posX = layout.door.position[0];
				let posZ = layout.door.position[1];

				let rotX = layout.door.facing[0];
				let rotZ = layout.door.facing[1];

				const roughnessMipmapper2 = new RoughnessMipmapper(renderer);

				doorLoader.load('scene.gltf', function (door){

					door.scene.traverse(function (child) {

						if (child.isMesh) {
							roughnessMipmapper2.generateMipmaps(child.material);
							child.castShadow = true;
							child.receiveShadow = true;
						}

					});

					///Door is way off center in its source scene
					///[2,10] VS Intended [11,6]
					door.scene.position.x = (posX+0.6+9)*wall_size;
					door.scene.position.z = (posZ+0.5-4)*wall_size;

					door.scene.position.y += 2*wall_size;

					let doorGroup = new THREE.Group();

					const noTexture = new THREE.TextureLoader().load();
					const imageMat = new THREE.MeshBasicMaterial({map:noTexture});
					const imageGeo = new THREE.BoxGeometry(wall_size*0.8,wall_size,wall_size*0.2);
					let doorImage = new THREE.Mesh(imageGeo, imageMat);
					doorImage.position.x = (posX+1.5)*wall_size;
					doorImage.position.y = wall_size/2;
					doorImage.position.z = (posZ+0.2)*wall_size;

					doorGroup.add(door.scene);
					doorGroup.add(doorImage);

					scene.add(doorImage);

					scene.add(door.scene);

					doors.push(doorGroup);
					roughnessMipmapper2.dispose();
				});
			}

            function generateLights(){
                ambient_light = new THREE.AmbientLight(0xB52020, 0.4);
                scene.add(ambient_light);
				for (let i = 0; i < layout.torches.length; i++) {
					buildTorches(layout.torches[i][0], layout.torches[i][1]);
				}
            }

			function buildTorches(posX, posZ){
				const roughnessMipmapper2 = new RoughnessMipmapper(renderer);

				const torchLoader = new GLTFLoader().setPath('./models/torch/');
				const fireLoader = new GLTFLoader().setPath('./models/fire/');

				torchLoader.load('scene.gltf', function (holder) {

					holder.scene.traverse(function (child) {

						if (child.isMesh) {
							roughnessMipmapper2.generateMipmaps(child.material);
							child.castShadow = true;
							child.receiveShadow = true;
						}
					});

					let fireSound = new THREE.PositionalAudio(listener);
					let fireElement = document.getElementById('fire');
					fireSound.setMediaElementSource(fireElement);
					fireSound.setRefDistance(wall_size*0.09);
					holder.scene.add(fireSound);
					fireElement.play();
					fireElement.loop = true;
					torchesAudio.push(fireSound);

					let analyzer = new THREE.AudioAnalyser(fireSound,32);
					torchesAnalysers.push(analyzer);

					holder.scene.scale.set(wall_size*0.2, wall_size*0.2, wall_size*0.2);
					holder.scene.position.x = (posX+0.05)*wall_size;
					holder.scene.position.z = (posZ+0.5)*wall_size;
					//gltf2.scene.rotation.y += Math.PI / 2;
					holder.scene.position.y = wall_size*0.8;

					torchesHolders.push(holder.scene);

					scene.add(holder.scene);

					roughnessMipmapper2.dispose();

				});
				fireLoader.load('scene.gltf', function(fire){
					fire.scene.traverse(function (child) {

						if (child.isMesh) {
							roughnessMipmapper2.generateMipmaps(child.material);
							child.castShadow = true;
							child.receiveShadow = true;
						}
					});

					fire.scene.scale.set(wall_size*0.4, wall_size*0.4, wall_size*0.4);
					fire.scene.position.x = (posX-1)*wall_size;
					fire.scene.position.z = (posZ-0.2)*wall_size;
					//gltf2.scene.rotation.y += Math.PI / 2;
					fire.scene.position.y = wall_size*0.85;

					scene.add(fire.scene);
					torchesFire.push(fire.scene);
					roughnessMipmapper2.dispose();
				});
				let torchLight = new THREE.SpotLight(0xFF5555, 2);
				torchLight.position.x = (posX+1.5)*wall_size;
				torchLight.position.y = wall_size*0.85;
				torchLight.position.z = (posZ+0.5)*wall_size;
				torchLight.angle = Math.PI / 4;
				torchLight.penumbra = 0.4;
				torchLight.decay = 2;
				torchLight.distance = 1500;

				torchLight.castShadow = true;
				torchLight.shadow.mapSize.width = 1024;
				torchLight.shadow.mapSize.height = 1024;
				torchLight.shadow.camera.near = 10;
				torchLight.shadow.camera.far = 200;
				torchLight.shadow.focus = 1;
				scene.add(torchLight);
				torchesLights.push(torchLight);
			}

		</script>

	</body>
</html>
