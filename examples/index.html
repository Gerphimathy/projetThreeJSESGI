<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Projet final de WebGL</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<audio id="fire" preload="auto" style="display: none">
		<source src="son/feu.mp3" type="audio/mpeg">
	</audio>
	<body>
		<div id="container"></div>
		<script type="module">

			import * as THREE from '../build/three.module.js';
            import {DoomControls} from './doomControls.js';
// 			import {OrbitControls} from "../examples/jsm/controls/OrbitControls.js";
			import Stats from "./jsm/libs/stats.module.js";
			import {RoughnessMipmapper} from "./jsm/utils/RoughnessMipmapper.js";
			import {GLTFLoader} from "./jsm/loaders/GLTFLoader.js";

			let camera, scene, renderer;
			let layout;
            let doomControls;
            let stats;
            let wall_size = 280; // Unit : cm
			let ambient_light;
			let torchesHolders = []; let torchesFire = []; let torchesLights = []; let torchesAnalysers = []; let torchesAudio = []; let torchesOn = false;
			let lightVariation = 1;
			let walls = [];
			let spookyRunner = [];

			let openingDoor = [];

			const listener = new THREE.AudioListener();
			const cameraHeight = 180;
			layout = readJson('layout.json');
			console.log(layout);


			init();
			animate();

			function degrees_to_radians(degrees)
			{
			  var pi = Math.PI;
			  return degrees * (pi/180);
			}

			function readJson(file) {
				var jObject;
				var req = new XMLHttpRequest();
				req.open("GET", "./layout.json", false);
				req.onreadystatechange = function () {
					if (req.readyState === 4) {
						jObject = JSON.parse(req.responseText);
						console.log("Loaded Json: '"+file+"'");
					}
				}
				req.send();
				return jObject;
			}

			function init() {

// 			    startOrbitControls();

				generateCamera();

				scene = new THREE.Scene();
				scene.background = new THREE.TextureLoader().load('./textures/red_sky.jpg');
				scene.fog = new THREE.Fog(new THREE.Color(0xdd0000), 0.25, wall_size*6);

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.setAnimationLoop(animate);

                stats = new Stats();

				document.body.appendChild( renderer.domElement );
                document.getElementById("container").appendChild(stats.dom);
                doomControls = new DoomControls(camera);
                doomControls.canFly = true;
				window.addEventListener( 'resize', onWindowResize );

				generateGround();
                generateLabyrinth();
                generateLights();
				generateSpooks();
				generateBonjour();
				generateHanged();
			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {
                stats.begin();
				//if (camera.position.y!==cameraHeight) camera.position.y = cameraHeight;
				let tempPos = [camera.position.x, camera.position.z];
                doomControls.update();
				checkProximity(tempPos);
				renderer.render( scene, camera );
				lightVariation *= -1;

				for (let i = 0; i < torchesAnalysers.length; i++) {
					torchesLights[i].angle += lightVariation*(torchesAnalysers[i].getAverageFrequency()/256);
					torchesFire[i].scale.y += lightVariation*(torchesAnalysers[i].getAverageFrequency()/256)*(wall_size*0.5);
					if(torchesFire[i].scale.y<wall_size*0.35) torchesFire[i].scale.y = wall_size*0.35;
					if(torchesFire[i].scale.y>wall_size*0.45) torchesFire[i].scale.y = wall_size*0.45;
				}

				if (!spookyRunner["active"]
						&& camera.position.x>=layout.runner.trigger[0]*wall_size && camera.position.x<(layout.runner.trigger[0]+1)*wall_size
						&& camera.position.z>=layout.runner.trigger[1]*wall_size && camera.position.z<(layout.runner.trigger[1]+1)*wall_size
				) spookyRunner["active"] = true;
				if (spookyRunner["active"]&&spookyRunner["frame"]!==layout.runner.time){

					let initX = (layout.runner.start[0]+0.5)*(wall_size);
					let initZ = (layout.runner.start[1]+0.5)*(wall_size);

					let destX = (layout.runner.end[0]+0.5)*(wall_size);
					let destZ = (layout.runner.end[1]+0.5)*(wall_size);

					let distX = Math.abs(destX-initX)/layout.runner.time;
					let distZ = Math.abs(destZ-initZ)/layout.runner.time;

					if (distX<initX) spookyRunner["elem"].position.x += distX;
					else spookyRunner["elem"].position.x -= distX;

					if (distZ<initZ) spookyRunner["elem"].position.z += distZ;
					else spookyRunner["elem"].position.z -= distZ;

					spookyRunner["frame"]++;
				}
				if(spookyRunner["active"] && spookyRunner["frame"] === layout.runner.time) {
					spookyRunner.elem.position.y *= -3*wall_size;
					spookyRunner["active"] = false;
				}

				if (!openingDoor["open"]
						&& camera.position.x>=layout.door.trigger[0]*wall_size && camera.position.x<(layout.door.trigger[0]+1)*wall_size
						&& camera.position.z>=layout.door.trigger[1]*wall_size && camera.position.z<(layout.door.trigger[1]+1)*wall_size
						&& openingDoor["frame"] === 0
				) openingDoor["open"] = true;


				if (openingDoor["open"] && openingDoor["frame"] !== layout.door.time){
					let change = (layout.door.angle*(Math.PI/180))/layout.door.time;

					openingDoor["pivot"].rotateY(change);

					openingDoor["frame"]++;
				}

				if (!torchesOn
						&& camera.position.x>=layout.torchesOff.trigger[0]*wall_size && camera.position.x<(layout.torchesOff.trigger[0]+1)*wall_size
						&& camera.position.z>=layout.torchesOff.trigger[1]*wall_size && camera.position.z<(layout.torchesOff.trigger[1]+1)*wall_size
				){
					torchesOn = true;
					for (let i = 0; i < layout.torchesOff.locations.length; i++){
						triggerTorches(layout.torchesOff.locations[i][0],layout.torchesOff.locations[i][1], false);
					}
				}
                stats.end();
			}

/*
 			function startOrbitControls(){
				const controls = new OrbitControls(camera, renderer.domElement);
                controls.minDistance = 10;
                controls.maxDistance = 2000;
                controls.enablePan = false;
                controls.maxPolarAngle = 85 * Math.PI / 180;
            }
*/
			function checkProximity(preMovePosition){
				for (let x = -1; x <= 1; x++){
					for (let z = -1; z <= 1; z++){
						let ray = new THREE.Raycaster(camera.position, new THREE.Vector3(x,0,z));
						let proximityCheckResults = ray.intersectObjects(walls);
						if (proximityCheckResults.length>0 && proximityCheckResults[0].distance<=10) {
							camera.position.set(preMovePosition[0], cameraHeight, preMovePosition[1]);
						}
					}
				}
			}
			function generateCamera(){
                camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 5000 );

                camera.position.x = layout.start[0]*wall_size-2*wall_size;
                camera.position.y = cameraHeight;
                camera.position.z = layout.start[1]*(wall_size)+0.5*wall_size;

                camera.rotation.set(0, -Math.PI/2, 0);
				camera.add(listener);
			}

			function generateGround(){
				const ground_text = new THREE.TextureLoader().load('./textures/ground.jpg');
                const ground_material = new THREE.MeshPhongMaterial({map:ground_text});
                const ground_geometry = new THREE.BoxGeometry(wall_size*layout.height,50,wall_size*layout.width);
                let ground = new THREE.Mesh(ground_geometry, ground_material);
                ground.receiveShadow = true;
                ground.castShadow = true;
                ground.position.x = wall_size*layout.height/2;
                ground.position.y = -25;
                ground.position.z = wall_size*layout.width/2;
                scene.add(ground);
			}

			function generateLabyrinth(){
                let i, j;

                for(i = 0; i < layout.height; i++){
                    for(j = 0; j < layout.width; j++){
                        if(layout.layout[i][j] === 1){
                            const wall_text = new THREE.TextureLoader().load('./textures/walls.jpg');
                            const wall_material = new THREE.MeshPhongMaterial({map:wall_text});
                            const wall_geometry = new THREE.BoxGeometry(wall_size,wall_size,wall_size);
	                        let wall = new THREE.Mesh(wall_geometry, wall_material);
                            wall.receiveShadow = true;
                            wall.castShadow = true;
                            wall.position.x = (j+.5)*wall_size;
                            wall.position.y = wall_size/2;
                            wall.position.z = (i+.5)*wall_size;
                            layout.layout[i][j] = wall;
                            scene.add(layout.layout[i][j]);
							walls.push(wall);

                        }
                    }
                }

				const door_text = new THREE.TextureLoader().load('./textures/gate.png');
				const door_material = new THREE.MeshPhongMaterial({map:door_text});
				const door_geometry = new THREE.BoxGeometry(wall_size,wall_size,wall_size*0.1);
				let door = new THREE.Mesh(door_geometry, door_material);

				let pivot = new THREE.Object3D();
				pivot.position.x = (layout.door.position[0]+1)*wall_size;
				pivot.position.y = wall_size/2;
				pivot.position.z = (layout.door.position[1]+1)*wall_size;

				pivot.add(door);

				door.position.x -= 0.5*wall_size;

				openingDoor = {
					elem: door,
					pivot: pivot,
					open: false,
					frame:0
				};

				scene.add(openingDoor["pivot"]);
			}

            function generateLights(){
                ambient_light = new THREE.AmbientLight(0xB52020, 0.4);
                scene.add(ambient_light);
				for (let i = 0; i < layout.torches.length; i++) {
					buildTorches(layout.torches[i][0], layout.torches[i][1], false);
				}
				for (let i = 0; i < layout.torchesLat.length; i++) {
					buildTorches(layout.torchesLat[i][0], layout.torchesLat[i][1], true);
				}
				for (let i = 0; i < layout.torchesOff.locations.length; i++){
					buildTriggeringTorches(layout.torchesOff.locations[i][0],layout.torchesOff.locations[i][1], false);
				}
            }

			function buildTorches(posX, posZ, lateral){
				const roughnessMipmapper2 = new RoughnessMipmapper(renderer);

				const torchLoader = new GLTFLoader().setPath('./models/torch/');
				const fireLoader = new GLTFLoader().setPath('./models/fire/');

				torchLoader.load('scene.gltf', function (holder) {

					holder.scene.traverse(function (child) {

						if (child.isMesh) {
							roughnessMipmapper2.generateMipmaps(child.material);
							child.castShadow = true;
							child.receiveShadow = true;
						}
					});

					holder.scene.scale.set(wall_size*0.2, wall_size*0.2, wall_size*0.2);
					if(!lateral){
						holder.scene.position.x = (posX+0.05)*wall_size;
						holder.scene.position.z = (posZ+0.5)*wall_size;
						holder.scene.position.y = wall_size*0.55;
					}else{
						holder.scene.position.z = (posZ+0.95)*wall_size;
						holder.scene.position.x = (posX+0.5)*wall_size;
						holder.scene.rotation.y += Math.PI / 2;
						holder.scene.position.y = wall_size*0.55;
					}

					torchesHolders.push(holder.scene);

					scene.add(holder.scene);

					let fireSound = new THREE.PositionalAudio(listener);
					let fireElement = document.getElementById('fire');
					fireSound.setMediaElementSource(fireElement);
					fireSound.setRefDistance(wall_size*0.09);
					holder.scene.add(fireSound);
					fireElement.play();
					fireElement.loop = true;
					torchesAudio.push(fireSound);

					let analyzer = new THREE.AudioAnalyser(fireSound,32);
					torchesAnalysers.push(analyzer);

					roughnessMipmapper2.dispose();

				});
				fireLoader.load('scene.gltf', function(fire){
					fire.scene.traverse(function (child) {

						if (child.isMesh) {
							roughnessMipmapper2.generateMipmaps(child.material);
							child.castShadow = true;
							child.receiveShadow = true;
						}
					});

					fire.scene.scale.set(wall_size*0.4, wall_size*0.4, wall_size*0.4);
					if(!lateral){
						fire.scene.position.x = (posX-1)*wall_size;
						fire.scene.position.z = (posZ-0.2)*wall_size;
						fire.scene.position.y = wall_size*0.60;
					}else{
						fire.scene.position.z = (posZ+0.2)*wall_size;
						fire.scene.position.x = (posX-0.6)*wall_size;
						fire.scene.position.y = wall_size*0.60;
					}

					scene.add(fire.scene);
					torchesFire.push(fire.scene);
					roughnessMipmapper2.dispose();
				});
				let torchLight = new THREE.SpotLight(0xFF5555, 2);
				if(!lateral){
					torchLight.position.x = (posX+1.5)*wall_size;
					torchLight.position.y = wall_size*0.60;
					torchLight.position.z = (posZ+0.5)*wall_size;
				}else{
					torchLight.position.x = (posX+1.7)*wall_size;
					torchLight.position.y = wall_size*0.60;
					torchLight.position.z = (posZ+1.5)*wall_size;
				}

				torchLight.angle = Math.PI / 4;
				torchLight.penumbra = 0.4;
				torchLight.decay = 2;
				torchLight.distance = 1500;

				torchLight.castShadow = true;
				torchLight.shadow.mapSize.width = 1024;
				torchLight.shadow.mapSize.height = 1024;
				torchLight.shadow.camera.near = 10;
				torchLight.shadow.camera.far = 200;
				torchLight.shadow.focus = 1;
				scene.add(torchLight);
				torchesLights.push(torchLight);
			}

			function buildTriggeringTorches(posX, posZ, lateral){
				const roughnessMipmapper2 = new RoughnessMipmapper(renderer);

				const torchLoader = new GLTFLoader().setPath('./models/torch/');

				torchLoader.load('scene.gltf', function (holder) {

					holder.scene.traverse(function (child) {

						if (child.isMesh) {
							roughnessMipmapper2.generateMipmaps(child.material);
							child.castShadow = true;
							child.receiveShadow = true;
						}
					});

					holder.scene.scale.set(wall_size*0.2, wall_size*0.2, wall_size*0.2);
					if(!lateral){
						holder.scene.position.x = (posX+0.05)*wall_size;
						holder.scene.position.z = (posZ+0.5)*wall_size;
						holder.scene.position.y = wall_size*0.55;
					}else{
						holder.scene.position.z = (posZ+0.95)*wall_size;
						holder.scene.position.x = (posX+0.5)*wall_size;
						holder.scene.rotation.y += Math.PI / 2;
						holder.scene.position.y = wall_size*0.55;
					}

					torchesHolders.push(holder.scene);

					scene.add(holder.scene);

					roughnessMipmapper2.dispose();

				});
			}

			function triggerTorches(posX, posZ, lateral){
				const roughnessMipmapper2 = new RoughnessMipmapper(renderer);

				const fireLoader = new GLTFLoader().setPath('./models/fire/');

				fireLoader.load('scene.gltf', function(fire){
					fire.scene.traverse(function (child) {

						if (child.isMesh) {
							roughnessMipmapper2.generateMipmaps(child.material);
							child.castShadow = true;
							child.receiveShadow = true;
						}
					});

					fire.scene.scale.set(wall_size*0.4, wall_size*0.4, wall_size*0.4);
					if(!lateral){
						fire.scene.position.x = (posX-1)*wall_size;
						fire.scene.position.z = (posZ-0.2)*wall_size;
						fire.scene.position.y = wall_size*0.60;
					}else {
						fire.scene.position.z = (posZ + 0.2) * wall_size;
						fire.scene.position.x = (posX - 0.6) * wall_size;
						fire.scene.position.y = wall_size * 0.60;
					}

					let fireSound = new THREE.PositionalAudio(listener);
					let fireElement = document.getElementById('fire');
					fireSound.setMediaElementSource(fireElement);
					fireSound.setRefDistance(wall_size*0.09);
					fire.scene.add(fireSound);
					fireElement.play();
					fireElement.loop = true;
					torchesAudio.push(fireSound);

					let analyzer = new THREE.AudioAnalyser(fireSound,32);
					torchesAnalysers.push(analyzer);

					scene.add(fire.scene);
					torchesFire.push(fire.scene);
					roughnessMipmapper2.dispose();
				});
				let torchLight = new THREE.SpotLight(0xFF5555, 2);
				if(!lateral){
					torchLight.position.x = (posX+1.5)*wall_size;
					torchLight.position.y = wall_size*0.60;
					torchLight.position.z = (posZ+0.5)*wall_size;
				}else{
					torchLight.position.x = (posX+1.7)*wall_size;
					torchLight.position.y = wall_size*0.60;
					torchLight.position.z = (posZ+1.5)*wall_size;
				}

				torchLight.angle = Math.PI / 4;
				torchLight.penumbra = 0.4;
				torchLight.decay = 2;
				torchLight.distance = 1500;

				torchLight.castShadow = true;
				torchLight.shadow.mapSize.width = 1024;
				torchLight.shadow.mapSize.height = 1024;
				torchLight.shadow.camera.near = 10;
				torchLight.shadow.camera.far = 200;
				torchLight.shadow.focus = 1;
				scene.add(torchLight);
				torchesLights.push(torchLight);
			}

			function generateSpooks(){
				let initX = (layout.runner.start[0]+0.5)*(wall_size);
				let initZ = (layout.runner.start[1]+0.5)*(wall_size);

				var spook_material_array = [];
				spook_material_array.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( './textures/skeleton.png' ), transparent: true, opacity: 1, color: 0xFF0000 }));
				spook_material_array.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( './textures/skeleton.png' ), transparent: true, opacity: 1, color: 0xFF0000 }));
				spook_material_array.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( './textures/skeleton.png' ), transparent: true, opacity: 1, color: 0xFF0000 }));
				spook_material_array.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( './textures/skeleton.png' ), transparent: true, opacity: 1, color: 0xFF0000 }));
				spook_material_array.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( './textures/skeleton.png' ), transparent: true, opacity: 1, color: 0xFF0000 }));
				spook_material_array.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( './textures/skeleton.png' ), transparent: true, opacity: 1, color: 0xFF0000 }));

				/*const wall_text = new THREE.TextureLoader().load('./textures/skeleton.png');*/
				/*const wall_material = new THREE.MeshPhongMaterial({map:wall_text});*/

				const spook_material = new THREE.MeshFaceMaterial(spook_material_array);

				const spook_geometry = new THREE.BoxGeometry(1,wall_size,wall_size*0.5);

				let spook = new THREE.Mesh(spook_geometry, spook_material);
				spook.receiveShadow = true;
				spook.castShadow = true;
				spook.position.x = initX;
				spook.position.y = wall_size/2;
				spook.position.z = initZ;

				spookyRunner = {
					elem: spook,
					frame: 0,
					active: false
				}

				scene.add(spook);

			}

			function generateBonjour(){
				const bonjour_geometry = new THREE.BoxGeometry( 1, wall_size/3, wall_size/2.5 );
				var bonjour_material_array = [];
				bonjour_material_array.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( './textures/sign.png' ), transparent: true, opacity: 1, color: 0xFF0000 }));
				bonjour_material_array.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( './textures/sign.png' ), transparent: true, opacity: 1, color: 0xFF0000 }));
				bonjour_material_array.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( './textures/sign.png' ), transparent: true, opacity: 1, color: 0xFF0000 }));
				bonjour_material_array.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( './textures/sign.png' ), transparent: true, opacity: 1, color: 0xFF0000 }));
				bonjour_material_array.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( './textures/sign.png' ), transparent: true, opacity: 1, color: 0xFF0000 }));
				bonjour_material_array.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( './textures/sign.png' ), transparent: true, opacity: 1, color: 0xFF0000 }));
				const bonjour_material = new THREE.MeshFaceMaterial(bonjour_material_array);
				const bonjour = new THREE.Mesh( bonjour_geometry, bonjour_material );

				bonjour.position.x = layout.start[0]*wall_size + wall_size;
				bonjour.position.y = cameraHeight-20;
				bonjour.position.z = layout.start[1]*(wall_size) - 1.5*wall_size;

				scene.add( bonjour );
			}

			function generateHanged(){
				const hangedLoader = new GLTFLoader().setPath('./models/hanged/');

				hangedLoader.load('scene.gltf', function(hanged){
					hanged.scene.traverse(function (child) {

						if (child.isMesh) {
							//roughnessMipmapper2.generateMipmaps(child.material);
							child.castShadow = true;
							child.receiveShadow = true;
						}
					});

					hanged.scene.scale.set(wall_size*0.6, wall_size*0.6, wall_size*0.6);
					hanged.scene.position.x = layout.start[0]*wall_size + 11.5*wall_size;
					hanged.scene.position.y = cameraHeight-200;
					hanged.scene.position.z = layout.start[1]*(wall_size) + 4.5*wall_size;
					hanged.scene.rotation.y = degrees_to_radians(-180);

					scene.add(hanged.scene);
					//roughnessMipmapper2.dispose();
				});
			}

		</script>

	</body>
</html>
