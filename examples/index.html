<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Projet final de WebGL</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>
		<div id="container"></div>
		<script type="module">

			import * as THREE from '../build/three.module.js';
            import {DoomControls} from './doomControls.js';
// 			import {OrbitControls} from "../examples/jsm/controls/OrbitControls.js";
			import Stats from "./jsm/libs/stats.module.js";
			import {RoughnessMipmapper} from "./jsm/utils/RoughnessMipmapper.js";
			import {GLTFLoader} from "./jsm/loaders/GLTFLoader.js";

			let camera, scene, renderer;
			let layout;
            let doomControls;
            let stats;
            let wall_size = 200; // Unit : cm
			let ambient_light;
			let torchesHolders = [];
			let torchesFire = [];
			let torchesLights = [];

			layout = readJson('layout.json');
			console.log(layout);


			init();
			animate();

			function readJson(file) {
				var jObject;
				var req = new XMLHttpRequest();
				req.open("GET", "./layout.json", false);
				req.onreadystatechange = function () {
					if (req.readyState === 4) {
						jObject = JSON.parse(req.responseText);
						console.log("Loaded Json: '"+file+"'");
					}
				}
				req.send();
				return jObject;
			}

			function init() {

// 			    startOrbitControls();

				generateCamera();


				scene = new THREE.Scene();
				scene.background = new THREE.TextureLoader().load('./textures/red_sky.jpg');
				scene.fog = new THREE.Fog(new THREE.Color(0xdd0000), 0.25, wall_size*6);

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.setAnimationLoop(animate);

                stats = new Stats();

				document.body.appendChild( renderer.domElement );
                document.getElementById("container").appendChild(stats.dom);
                doomControls = new DoomControls(camera);
                doomControls.canFly = true;
				window.addEventListener( 'resize', onWindowResize );

				generateGround();
                generateLabyrinth();
                generateLights();



			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {
                stats.begin();
                doomControls.update();
				renderer.render( scene, camera );
                stats.end();
			}

/*
 			function startOrbitControls(){
				const controls = new OrbitControls(camera, renderer.domElement);
                controls.minDistance = 10;
                controls.maxDistance = 2000;
                controls.enablePan = false;
                controls.maxPolarAngle = 85 * Math.PI / 180;
            }
*/
			function generateCamera(){
                camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 5000 );
                
                camera.position.x = layout.start[0]*wall_size-2*wall_size;
                camera.position.y = 180;
                camera.position.z = layout.start[1]*(wall_size)+0.5*wall_size;

                camera.rotation.set(0, -Math.PI/2, 0);
			}

			function generateGround(){
				const ground_text = new THREE.TextureLoader().load('./textures/ground.jpg');
                const ground_material = new THREE.MeshPhongMaterial({map:ground_text});
                const ground_geometry = new THREE.BoxGeometry(wall_size*layout.height,50,wall_size*layout.width);
                let ground = new THREE.Mesh(ground_geometry, ground_material);
                ground.receiveShadow = true;
                ground.castShadow = true;
                ground.position.x = wall_size*layout.height/2;
                ground.position.y = -25;
                ground.position.z = wall_size*layout.width/2;
                scene.add(ground);
			}

			function generateLabyrinth(){
                let i, j;

                for(i = 0; i < layout.height; i++){
                    for(j = 0; j < layout.width; j++){
                        if(layout.layout[i][j] === 1){
                            const wall_text = new THREE.TextureLoader().load('./textures/crying_obsidian.png');
                            const wall_material = new THREE.MeshPhongMaterial({map:wall_text});
                            const wall_geometry = new THREE.BoxGeometry(wall_size,wall_size,wall_size);
	                        let wall = new THREE.Mesh(wall_geometry, wall_material);
                            wall.receiveShadow = true;
                            wall.castShadow = true;
                            wall.position.x = (j+.5)*wall_size;
                            wall.position.y = wall_size/2;
                            wall.position.z = (i+.5)*wall_size;
                            layout.layout[i][j] = wall;
                            scene.add(layout.layout[i][j]);
                        }
                    }
                }
			}

            function generateLights(){
                ambient_light = new THREE.AmbientLight(0xB52020, 0.4);
                scene.add(ambient_light);
				for (let i = 0; i < layout.torches.length; i++) {
					buildTorches(layout.torches[i][0], layout.torches[i][1])
				}
            }

			function buildTorches(posX, posZ){
				const roughnessMipmapper2 = new RoughnessMipmapper(renderer);

				const torchLoader = new GLTFLoader().setPath('./models/torch/');
				const fireLoader = new GLTFLoader().setPath('./models/fire/');
				torchLoader.load('scene.gltf', function (holder) {

					holder.scene.traverse(function (child) {

						if (child.isMesh) {
							roughnessMipmapper2.generateMipmaps(child.material);
							child.castShadow = true;
							child.receiveShadow = true;
						}
					});

					holder.scene.scale.set(wall_size*0.2, wall_size*0.2, wall_size*0.2);
					holder.scene.position.x = (posX+0.05)*wall_size;
					holder.scene.position.z = (posZ+0.5)*wall_size;
					//gltf2.scene.rotation.y += Math.PI / 2;
					holder.scene.position.y = wall_size*0.8;

					torchesHolders.push(holder.scene);

					scene.add(holder.scene);

					roughnessMipmapper2.dispose();

				});
				fireLoader.load('scene.gltf', function(fire){
					fire.scene.traverse(function (child) {

						if (child.isMesh) {
							roughnessMipmapper2.generateMipmaps(child.material);
							child.castShadow = true;
							child.receiveShadow = true;
						}
					});


					fire.scene.scale.set(wall_size*0.4, wall_size*0.4, wall_size*0.4);
					fire.scene.position.x = (posX-1)*wall_size;
					fire.scene.position.z = (posZ-0.2)*wall_size;
					//gltf2.scene.rotation.y += Math.PI / 2;
					fire.scene.position.y = wall_size*0.85;

					torchesFire.push(fire.scene);

					scene.add(fire.scene);

					roughnessMipmapper2.dispose();
				});
				let torchLight = new THREE.SpotLight(0xFF5555, 2);
				torchLight.position.x = (posX+1.5)*wall_size;
				torchLight.position.y = wall_size*0.85;
				torchLight.position.z = (posZ+0.5)*wall_size;
				torchLight.angle = Math.PI / 4;
				torchLight.penumbra = 0.4;
				torchLight.decay = 2;
				torchLight.distance = 1500;

				torchLight.castShadow = true;
				torchLight.shadow.mapSize.width = 1024;
				torchLight.shadow.mapSize.height = 1024;
				torchLight.shadow.camera.near = 10;
				torchLight.shadow.camera.far = 200;
				torchLight.shadow.focus = 1;
				scene.add(torchLight);
				torchesLights.push(torchLight);
			}

		</script>

	</body>
</html>
